<!doctype html>
<html>
<head>
<meta http-equiv="Cache-Control" content="no-cache">
<meta charset="utf-8">
<link rel="stylesheet" href="css/Base.css">
<link rel="stylesheet" href="css/fon.css">
<link rel="stylesheet" href="css/font.css">
<link href="https://fonts.googleapis.com/css?family=Poiret+One" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Underdog" rel="stylesheet">
<title>Занятие №5 курса HTML5&amp;CSS</title>

</head>

<body>

<header>  
  <div class="floatfigure">
  	<img src="pict/HTML5CSS3.png" width="80" alt="HTML & CSS">
</div>
<h1>HTML5 &amp; CSS</h1>
</header>

<nav>
	<a href="?url=index">Главная</a>
	<a href="?url=1erer">Обучение</a>
	<a href="?url=dop">Дополнительная информация</a>
	<a href="?url=cont">Контакты</a>
</nav>

<div id="content">

<article>
 <header>
  <small>   <time datetime="2016-06-16">Опубликовано 16 июня 2016</time>   </small>
  <h1>Урок 6. CSS3 Современное использование шрифтов. Работа с  текстом.</h1></header>
<figure class="floatfigure">
  	<img src="pict/HTMLCSS.png" width="100" alt="HTML&CSS">
<figcaption>HTML5  CSS</figcaption>
</figure>

  <p>&nbsp;</p>
</article>
<p>Работа с шрифтами.  Веб-шрифты GOOGLE. Размещение текста в  несколько колонок. Рассмотрим механизмы  представления текстовой информации: оформление, выравнивание, отступы и т.д. <br>
  Используем в нашем  проекте новые возможности работы с шрифтами, текстом. Используем шрифты GOOGLE. Преобразуем текстовую информацию нашего  проекта в соответствии с новыми возможностями.</p>
<p>&nbsp;</p>
<h2>Введение</h2>
<p>Ранее приходилось работать с ограниченным набором шрифтов,  пригодных для веб-страниц. В данном случае речь идет о шрифтах, о которых  заведомо известно, что они работают на разных браузерах и в разных операционных  системах. Данная ситуация не подходит для современных веб-страниц, где шрифты  играют огромную роль в создании общего впечатления о документе.<br>
  В CSS3 поддержка сложных шрифтов обеспечивается посредством  возможности @font-face, которая применяется следующим образом:</p>
<ol>
  <li>Требуемый шрифт (или, более вероятно, несколько  версий шрифта для поддержки разных браузеров) загружается на сайт.</li>
  <li>Каждый шрифт регистрируется в таблице стилей с  помощью команды @font-face.</li>
  <li>Зарегистрированный шрифт используется в правилах  стиля указанием его названия, точно так же, как и обычные веб-шрифты.</li>
  <li>Когда браузер обнаруживает таблицу стилей, в  которой используется специальный веб-шрифт, он загружает этот шрифт с сервера в  свой кэш для временного хранения страниц и изображений. После этого браузер  использует этот шрифт только для данной страницы или сайта. Если этот же шрифт  указывается в другой странице, он должен быть зарегистрирован на этой странице  и загружен на ее сервер, откуда он может быть загружен браузером в свой кэш.</li>
</ol>
<p>&nbsp;</p>
<h2>Форматы веб-шрифтов</h2>
<p>Хотя все современные браузеры поддерживают возможность  @font-face, не все они поддерживают одинаковые типы файлов шрифтов. Например,  Internet Explorer, который обеспечивает использование @font-face в течение  многих лет, поддерживает только файлы типа EOT (Embedded OpenType). Этот формат  предоставляет ряд преимуществ, например, в нем используется сжатие для  уменьшения объема файла шрифтов, а также применяется строгое лицензирование для  веб-сайтов, чтобы шрифт нельзя было украсть с одного сайта и использовать на  другом.</p>
<p> Но формат EOT никогда ни пользовался большой популярностью и  не используется никакими другими браузерами. Вместо него браузеры работают с  более знакомыми стандартами шрифтов, применяемыми в компьютерных приложениях —  TTF (TrueType) и OTF (OpenType PostScript). Кроме этого, существуют еще два  типа отображения шрифтов — SVG и WOFF. В таблице ниже дано краткое описание  всех этих форматов шрифтов: </p>
<table border="1" cellspacing="0" cellpadding="0">
  <tr>
    <th colspan="3">Форматы внедряемых шрифтов</th>
  </tr>
  <tr>
    <th><strong>Формат</strong></th>
    <th><strong>Описание</strong></th>
    <th><strong>Используется в</strong></th>
  </tr>
  <tr>
    <td><p>TTF (TrueType), OTF (OpenType PostScript)</p></td>
    <td><p>Распространенные форматы шрифтов настольных компьютеров</p></td>
    <td><p>Firefox (до версии 3.6), Chrome (до версии 6), Safari и Opera</p></td>
  </tr>
  <tr>
    <td><p>EOT (Embedded OpenType)</p></td>
    <td><p>Формат, специфичный для продуктов корпорации Microsoft. Не завоевал    популярности у браузеров, за исключением Internet Explorer</p></td>
    <td><p>Internet Explorer (до версии IE 9)</p></td>
  </tr>
  <tr>
    <td><p>SVG (Scalable Vector Graphics)</p></td>
    <td><p>Универсальный графический формат, который можно использовать для создания    шрифтов. Дает хорошие, но не отличные результаты — медленно отображается и    демонстрирует текст пониженного качества</p></td>
    <td><p>Safari Mobile (на iPhone и iPad до iOS 4.2) и мобильные устройства под управлением    операционной системы Android</p></td>
  </tr>
  <tr>
    <td><p>WOFF (Web Open Font Format)</p></td>
    <td><p>Возможно, единый формат шрифтов будущего. Поддерживается новыми версиями    браузеров</p></td>
    <td><p>Любой поддерживающий браузер, начиная с Internet Explorer 9, Firefox 3.6    и Chrome 6</p></td>
  </tr>
</table>
<p>В итоге можно сказать следующее: если вы хотите использовать  возможность @font-face и поддерживать широкий диапазон браузеров, вам нужно  предоставлять ваш шрифт в нескольких разных форматах. Как минимум, шрифт нужно  предоставить в формате TTF или OTF (без разницы), EOT и SVG. Хорошо (но не  обязательно) также предоставить шрифт в перспективном формате WOFF, может стать  более популярным и лучше поддерживаемым в будущем. (Одним из достоинств этого  формата является использование сжатых файлов, что сокращает время их загрузки.)</p>
<p>  Даже если вы последуете всем приведенным ранее правилам и  предоставите все требуемые форматы шрифтов, ожидайте некоторые загвоздки. В  частности, с веб-шрифтами иногда возникают следующие проблемы:</p>
<ul>
  <li>Многие шрифты выглядят плохо в операционной  системе Windows XP, т.к. в настройках многих компьютеров с этой операционной  системой отключено сглаживание (anti-aliasing). (А без применения сглаживания  шрифты выглядят очень непривлекательно.)</li>
  <li>От пользователей поступали жалобы о проблемах с  печатью определенных внедренных шрифтов из некоторых браузеров или в  операционных системах.</li>
  <li>Некоторые браузеры страдают проблемой FOUT  (Flash of Unstyled Text, вспышка нестилизованного текста). Это явление  происходит, когда внедренный шрифт не успевает загрузиться вовремя, и страница  отображается сначала в резервном шрифте, а потом воспроизводится повторно на  встроенном шрифте. Эта проблема особенно заметна в старых версиях браузера  Firefox. Если вас это сильно беспокоит, можете воспользоваться библиотекой  JavaScript от Google, позволяющей разработчику определить резервные стили,  которые используются вместо незагруженных внедренных шрифтов, таким образом,  предоставляя ему полный контроль над воспроизведением текста в любое время.</li>
</ul>
<p>Хотя эти небольшие проблемы иногда и возникают, большинство  из них постепенно решается с выпуском новых версий браузеров. Например, браузер  Firefox теперь сводит эффект FOUT к минимуму, ожидая до трех секунд, пока не  загрузится внедренный шрифт, прежде чем использовать резервный шрифт.</p>
<h2>Наборы шрифтов</h2>
<p>На рисунке ниже показано несколько шрифтов из  предоставляемых на сайте Font Squirrel: <a href="http://www.fontsquirrel.com">www.fontsquirrel.com</a></p>
<p>&nbsp;</p>
  	<img src="image/image1.png"  alt="Рисунок 1 – пример выбора шрифтов с сайта Font Squirrel">
  <p>Рисунок 1 – пример выбора шрифтов с сайта Font Squirrel</p>
    
    
    
  <p>Сайт Font Squirrel предоставляет для загрузки несколько  сот шрифтов, организованных в разделы по категориям (такие  как, например, Calligraphic, Grunge или Retro). Все эти шрифты бесплатные для  любого использования, будь то на персональном компьютере для создания  документов или на веб-странице в Интернете.</p>
  <p>      Набор шрифтов загрузится в виде файла, сжатого в формате  ZIP, который содержит несколько файлов шрифта в разных форматах. Чтобы  использовать шрифт в своей веб-странице, файлы разных форматов шрифта нужно  загрузить на веб-сервер в папку этой веб-страницы. После этого шрифт нужно  зарегистрировать, чтобы он был доступным для использования в таблице стилей.  Регистрация выполняется с помощью правила @font-face в начале таблицы стилей,  которое выглядит следующим образом:</p>
 
<xmp id="scriptHTML">
  @font-face {
	font-family: 'MetrophobicRegular';
    src: url('Metrophobic-webfont.eot');
    src: local('Metrophobic'),
         url('Metrophobic-webfont.eot?#iefix') format('embedded-opentype'),
         url('Metrophobic-webfont.woff') format('woff'),
         url('Metrophobic-webfont.ttf') format('truetype'),
         url('Metrophobic-webfont.svg#MetrophobicRegular') format('svg');
    font-weight: normal;
    font-style: normal;
}
</xmp>
  
  
  <p>Строки приведенного кода выполняют следующие функции:</p>
  <ul>
    <li>Выражение @font-face регистрирует шрифт для его  дальнейшего применения в таблице стилей. </li>
    <li>Шрифту можно присвоить любое название. Это  название будет употреблено позже, при использовании шрифта.</li>
    <li>Первым должен быть указан формат EOT, т.к.  дальнейшая часть правила сбивает с толку Internet Explorer, и тот не обращает  внимания на остальные форматы. Функция таблицы стилей url() указывает браузеру  загрузить файл из обозначенного URL. Если шрифт размещен в одной папке с  веб-страницей, то здесь можно просто указать название файла.</li>
    <li>Функция local() указывает браузеру название  шрифта, и если этот шрифт установлен на компьютере посетителя веб-страницы,  браузер использует локальный шрифт. Но в редких случаях это может вызвать  проблемы. Например, в зависимости от того, где установлен шрифт на компьютере  посетителя, компьютеры Mac OS X могут вывести предупреждение о нарушении  безопасности, или же может загрузиться другой шрифт с таким же названием, как и  ваш. По этой причине веб-разработчики иногда указывают явно несуществующее имя  файла, чтобы браузер не нашел локального шрифта. В качестве простого имени  такого типа можно использовать какой-либо бессмысленный символ.</li>
    <li>Последний шаг — это сообщить браузеру о других  файлах шрифтов, которые он может использовать. Если имеется файл шрифта типа  WOFF, укажите этот файл первым, т.к. данный формат предоставляет наилучшее  качество шрифта. Следующим укажите файл шрифта формата TTF или OTF, а самым  последним — файл формата SVG.</li>
  </ul>
  <p>Зарегистрировав веб-шрифт с помощью функции ©font-face, вы можете  использовать его в любой таблице стилей. Для этого используется уже знакомое  нам свойство font-family, которому присваивается значение в виде названия  семейства шрифтов, зарегистрированного с помощью функции @font-face (в строке  2). Далее приведен пример использования этого шрифта в правиле таблицы стилей:</p>
<xmp id="scriptHTML">
body {
	font-family: Amerika;
}
</xmp>
  
  <p>&nbsp;</p>
  <div class="demo">
  <p style="font-family: MetrophobicRegular; font-size: 36px" > MetrophobicRegular </p>
 <p style="font-family: 3Dumb; font-size: 36px" > 3Dumb </p>
 <p style="font-family: 2Dumb; font-size: 36px" > 2Dumb </p>
 <p style="font-family: AlexBrush; font-size: 36px" >Пример шрифта AlexBrush Primer</p>
 <p style="font-family: Bentham; font-size: 36px" > Bentham </p> 
 <p style="font-family: BreeSerif-Regular; font-size: 36px" > BreeSerif-Regular </p>
 <p style="font-family: grand-hotel; font-size: 36px" > grand-hotel </p> 
 <p style="font-family: Alpha-Echo; font-size: 36px" > Пример шрифта Alpha-Echo Primer</p>
 <p style="font-family: Amerika; font-size: 36px" > Пример шрифта Amerika. Съешь еще немного этих мягких французких булочек</p>
 <p style="font-family: Capture-it; font-size: 36px" > Пример шрифта Capture-it. Съешь еще немного этих мягких французких булочек</p>
 </div>
 
 <h2>Веб-шрифты Google</h2>
 <p>Еще один источник бесплатных веб-шрифтов —- это служба  Google Web Fonts. Ее особенность в том, что пользователю не нужно беспокоиться  о форматах шрифтов, т.к. Google определяет браузер посетителя страницы и  автоматически отправляет файл шрифта нужного формата.</p>
 <p> Чтобы использовать шрифт Google в своих страницах, выполните  такую последовательность шагов:</p>
 <ol start="1" type="1">
   <li>Откройте в браузере страницу Google Web Fonts (https://fonts.google.com/). Откроется страница,       содержащая длинный список имеющихся в наличии шрифтов.</li>
   <li>Настройте опции поиска. Если вы знаете название       требуемого вам шрифта, введите его в поле поиска. В противном случае нужно       будет просматривать все шрифты, прокручивая страницу вверх, что для       латинских шрифтов может занять значительное время. Чтобы ускорить поиск,       можно отсортировать и отфильтровать список согласно определенным критериям.</li>
   <li>Обнаружив подходящий шрифт, щелкните по знаку «+».       Откроется новое окно, содержащее описание шрифта и все его подробности.</li>
   <li>Если на этом этапе вы решите использовать данный       шрифт, то вы можете скачать данный шрифт себе и использовать его так, как       показано в предыдущем примере или использовать код из ссылки на таблицу       стилей, которую нужно вставить в разметку вашей веб-страницы, и примера       правила таблицы стилей, применяющего шрифт.</li>
   <li>Вставьте в свою веб-страницу ссылку на таблицу       стилей. Например:</li>
 </ol>
 <div id="scriptHTML"> &lt;link href=&quot;https://fonts.googleapis.com/css?family=Underdog&quot; rel=&quot;stylesheet&quot;&gt;
</div>
 <p>Данная таблица стилей регистрирует шрифт посредством функции  @font-face, избавляя вас от необходимости выполнять эту работу самому. Но что  лучше всего, Google предоставляет файлы шрифтов, что, опять же, избавляет вас  от необходимости загружать их на свой веб-сайт.</p>
 <p> Используйте шрифт, обращаясь к нему по его названию, в любое  время. Например, далее приводится правило для применения должным образом  зарегистрированного шрифта Ceviche One в заголовках первого уровня,  предоставляющее резервный шрифт на случай, если браузер не сможет загрузить  основной шрифт:</p>
<xmp id="scriptHTML">
h1 {
font-family: 'Underdog', arial, serif;
}
</xmp>
<p>&nbsp;</p>
 <div class="demo">
 <p style="font-family: 'Poiret One', cursive; font-size: 36px" > Poiret One. Используется таблица стилей GOOGLE. Съешь еще немного этих мягких французких булочек</p>
 <p style="font-family: 'Poiret_One1', cursive; font-size: 36px" > Poiret One. Используется внутреннея таблица стилей и шрифт хранится на вашем сервере. Съешь еще немного этих мягких французких булочек</p>
  <p style="font-family: 'Underdog', cursive; font-size: 36px" > Underdog. Используется таблица стилей GOOGLE. Съешь еще немного этих мягких французких булочек</p>
 </div>
 <h2>Размещение текста в несколько колонок</h2>
 <p>В CSS3  был добавлен абсолютно новый модуль для размещения текста в несколько колонок,  таким образом предоставляя разработчикам гибкое средство для решения проблемы  длинного текста без потерь его читаемости. Создание нескольких колонок текста  не требует почти никаких усилий и может быть выполнено двумя способами. Первый  подход — это установить количество требуемых колонок с помощью свойства  column-count, как показано в следующем коде:</p>
 
   <xmp id="scriptHTML">
     .Content {
     text-align:justify;
     column-count:3;
     }
   </xmp>

 <p>Для браузеров Firefox, Chrome и Safari это свойство  используется с префиксом разработчика браузера:</p>
 <p>
  <xmp id="scriptHTML">
    .Content {
    text-align:justify;
    -moz-column-count: 3;
    -webkit-column-count: 3;
    column-count:3;
    }
  </xmp>
   
   Указание точного числа колонок лучше всего подходит для веб-страниц с компоновкой фиксированного размера. Но если размеры компоновки меняются в соответствии с размерами окна браузера, ширина колонок может оказаться слишком большой и текст в них будет трудно читать. Во избежание такой проблемы лучше не устанавливать точное число колонок, а дать указание браузеру, каким должен быть размер каждой колонки, используя свойство column-width, как показано далее:
   
  <xmp id="scriptHTML">
    .Content {
    text-align:justify;
    -moz-column-width: 10em;
    -webkit-column-width: 10em;
    column-width: 10em;
    }
  </xmp>

<div class="demo">
<h2>Размещение текста в несколько колонок</h2>
<div id="column">
<p>В CSS3  был добавлен абсолютно новый модуль для размещения текста в несколько колонок,  таким образом предоставляя разработчикам гибкое средство для решения проблемы  длинного текста без потерь его читаемости. Создание нескольких колонок текста  не требует почти никаких усилий и может быть выполнено двумя способами. Первый  подход — это установить количество требуемых колонок с помощью свойства  column-count, как показано в следующем коде:</p>
 
   <xmp id="scriptHTML">
     .Content {
     text-align:justify;
     column-count:3;
     }
   </xmp>

 <p>Для браузеров Firefox, Chrome и Safari это свойство  используется с префиксом разработчика браузера:</p>
 <p>
  <xmp id="scriptHTML">
    .Content {
    text-align:justify;
    -moz-column-count: 3;
    -webkit-column-count: 3;
    column-count:3;
    }
  </xmp>
   
   Указание точного числа колонок лучше всего подходит для веб-страниц с компоновкой фиксированного размера. Но если размеры компоновки меняются в соответствии с размерами окна браузера, ширина колонок может оказаться слишком большой и текст в них будет трудно читать. Во избежание такой проблемы лучше не устанавливать точное число колонок, а дать указание браузеру, каким должен быть размер каждой колонки, используя свойство column-width, как показано далее:
   
  <xmp id="scriptHTML">
    .Content {
    text-align:justify;
    -moz-column-width: 10em;
    -webkit-column-width: 10em;
    column-width: 10em;
    }
  </xmp>

</div>
</div>   
 </p>
 <p>Таким  образом, браузер может создать такое количество колонок, которое необходимо для  заполнения имеющегося пространства.</p>
 <p>С помощью CSS3 свойство column-gap Вы можете установить  величину отступа между столбцами текста.</p>
 
 <xmp id="scriptHTML">
 div {
column-count:4;
column-gap:50px;
}
</xmp>
 <div class="demo">
<h2>Размещение текста в несколько колонок</h2>
<div id="column2">
<p>В CSS3  был добавлен абсолютно новый модуль для размещения текста в несколько колонок,  таким образом предоставляя разработчикам гибкое средство для решения проблемы  длинного текста без потерь его читаемости. Создание нескольких колонок текста  не требует почти никаких усилий и может быть выполнено двумя способами. Первый  подход — это установить количество требуемых колонок с помощью свойства  column-count, как показано в следующем коде:</p>
 
   <xmp id="scriptHTML">
     .Content {
     text-align:justify;
     column-count:3;
     }
   </xmp>

 <p>Для браузеров Firefox, Chrome и Safari это свойство  используется с префиксом разработчика браузера:</p>
 <p>
  <xmp id="scriptHTML">
    .Content {
    text-align:justify;
    -moz-column-count: 3;
    -webkit-column-count: 3;
    column-count:3;
    }
  </xmp>
    
</div>
</div>
 <p>С помощью свойства column-rule Вы можете задать ширину, цвет  и стиль оформления пространства между столбцами.</p>
 <xmp id="scriptHTML">
div {
column-count:4;
column-rule:2px dotted #7F0055;
}
 </xmp>
 <div class="demo">
<h2>Размещение текста в несколько колонок</h2>
<div id="column3">
<p>В CSS3  был добавлен абсолютно новый модуль для размещения текста в несколько колонок,  таким образом предоставляя разработчикам гибкое средство для решения проблемы  длинного текста без потерь его читаемости. Создание нескольких колонок текста  не требует почти никаких усилий и может быть выполнено двумя способами. Первый  подход — это установить количество требуемых колонок с помощью свойства  column-count, как показано в следующем коде:</p>
 
   <xmp id="scriptHTML">
     .Content {
     text-align:justify;
     column-count:3;
     }
   </xmp>

 <p>Для браузеров Firefox, Chrome и Safari это свойство  используется с префиксом разработчика браузера:</p>
 <p>
  <xmp id="scriptHTML">
    .Content {
    text-align:justify;
    -moz-column-count: 3;
    -webkit-column-count: 3;
    column-count:3;
    }
  </xmp>
    
</div>
</div>
 <h2>Добавление теней к тексту</h2>
 <p>С помощью нового CSS3 свойства text-shadow Вы можете  добавлять к тексту элементов тени (к тексту одного элемента может быть  добавлено одновременно несколько теней).</p>
При задании тени для текста необходимо указать:  величину смещения тени от текста по горизонтали и вертикали (может быть  отрицательной), а также радиус размытия и цвет тени.
<xmp id="scriptHTML">
#shadow1 {
text-shadow:3px 2px #FFAE00;
}
#shadow2 {
text-shadow:1px 1px 10px #FFAE00;
}
#shadow3 {
text-shadow:2px 2px 2px #FFAE00, 2px 2px 15px #1435AD;
}
</xmp>
<h2>Свойство text-overflow</h2>
<p>В CSS3 было добавлено новое свойство text-overflow, которое  позволяет указать, что должно случиться с текстом вышедшем за пределы границ  элемента.</p>
<xmp id="scriptHTML">
#wrap1 {
text-overflow:ellipsis;
overflow:hidden;
}
#wrap2 {
text-overflow:clip;
overflow:hidden;
}
</xmp>
<h2>Свойство word-wrap</h2>
С помощью нового CSS3 свойства word-wrap Вы можете  указать, что длинные слова выходящие за пределы границ элемента должны  разделяться и переносится на новую строку.
<xmp id="scriptHTML">
#wrap2 {
word-wrap:break-word;
}
</xmp>
 <div class="demo">
 <p style="font-family: 'Amerika', cursive; font-size: 36px" id = "shadow1" id="wrap1"> Пример использования тени на шрифте Amerika. </p>
 <p style="font-family: 'Poiret_One1', cursive; font-size: 36px" id = "shadow2" id="wrap2"> Используется размытие тени на шрифте Poiret One. </p>
  <p style="font-family: 'Underdog', cursive; font-size: 36px" id = "shadow3" id="wrap3"> Используется оба вида тени на шрифте Underdog. </p>
 </div>
<p>&nbsp;</p>

<h2>Технология рисования canvas</h2>
<p>HTML 5 Canvas (канва  HTML 5) предоставляет способ вывода графики и рисования с использованием  JavaScript. Для каждого элемента canvas можно использовать контекст, в котором  нужно вызвать команды JavaScript для рисования на Canvas. Браузеры могут  реализовывать несколько контекстов элемента canvas и предоставлять различные  API для рисования. Следует также помнить, что рисование происходит в растровой  форме</p>
<p>На данном уроке вы узнаете, как использовать контекст  элемента canvas, основные функции для работы с canvas, включая линии, примитивы  фигур, изображения, текст и другие возможности. Предполагается, что вы владете  основами JavaScript.</p>
<h3>Основы использования Canvas</h3>
<p>Чтобы создать  Canvas-контекст, достаточно просто добавить элемент &lt;canvas&gt; в  HTML-документ:</p>
<xmp id="scriptHTML">
<canvas id="myCanvas" width="300" height="150">
Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS»
</canvas>
</xmp>
<p>Нужно добавить  идентификатор к элементу canvas, чтобы потом обратиться к нему в JavaScript,  также необходимо задать атрибуты width и height для определения ширины и высоты  элемента canvas. По умолчанию размер холста 150х300 пикселей.</p>
<p>Для рисования внутри  элемента canvas, нужно использовать JavaScript. Сначала нужно найти созданный  тег canvas с помощью функции getElementById, а потом инициализировать нужный  контекст. Как только это будет сделано, можно начинать рисование на канве,  используя доступные API-команды выбранного контекста. Следующий скрипт рисует  простой прямоугольник на канве (просмотреть пример использования Canvas):</p>
<p>
  <xmp id="scriptHTML">
    <script>
// Получить ссылку на элемент canvas по идентификатору.
var elem = document.getElementById('myCanvas');

// Проверка свойства и метода на доступность для обратной совместимости со старыми браузерами
if (elem && elem.getContext) {
  // Получить 2D контекст.
  // Для каждого элемента можно инициализировать только один контекст
  var context = elem.getContext('2d');
  if (context) {
    // Рисуем прямоугольник, задав координаты (x,y), а также его ширину и высоту.
    context.fillRect(0, 0, 150, 100);
  }
}
    </script>
  </xmp>
  
  <canvas id="myCanvas" width="300" height="150">
    Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS»
  </canvas>
</p>
<h3>Canvas 2D API</h3>
<h4>Заливки и границы фигур</h4>
<p>С помощью свойств  fillStyle и strokeStyle настраиваются цвета, используемые для заливки и линий  объектов. Значения цветов, используемые в этих методах, такие же как и в CSS:  шестнадцатеричные коды (#F5E6AB), rgb(), rgba() или даже hsla(), если браузер  поддерживает такой способ задания цвета.</p>
<p> Используя метод  fillRect, рисуется прямоугольник с заливкой. С помощью метода strokeRect рисуется  прямоугольник только с границами, без заливки. Для очистки части канвы, используется  метод clearRect. Три этих метода используют одинаковый набор аргументов: x, y,  width, height. Первые два аргумента задают координаты (x,y), а следующие два —  ширину и высоту прямоугольника.<br>
  Для изменения толщины  линий можно использовать свойство lineWidth.</p>
<script>
var elem = document.getElementById('myCanvas');
var context = elem.getContext('2d');
context.fillRect(0,0,100,200);
</script>
<h3>Окружность и круг</h3>
<xmp id="scriptHTML">
<canvas id="myCanvas2" width="300" height="150">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>

<script>
// Получить ссылку на элемент canvas по идентификатору.
var elem = document.getElementById('myCanvas2');

// Проверка свойства и метода на доступность для обратной совместимости со старыми браузерами
if (elem && elem.getContext) {
  // Получить 2D контекст.
  // Для каждого элемента можно инициализировать только один контекст
  var context = elem.getContext('2d');
  if (context) {
    context.beginPath();
	context.arc(75, 75, 40, 0, Math.PI*2, true);
	context.closePath();
	context.fillStyle = "#FFA500";
	context.fill(); // Если нужен круг, можно залить окружность

  }
}
</script>
</xmp>
<canvas id="myCanvas2" width="300" height="150">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>

<script>
// Получить ссылку на элемент canvas по идентификатору.
var elem = document.getElementById('myCanvas2');

// Проверка свойства и метода на доступность для обратной совместимости со старыми браузерами
if (elem && elem.getContext) {
  // Получить 2D контекст.
  // Для каждого элемента можно инициализировать только один контекст
  var context = elem.getContext('2d');
  if (context) {
    context.beginPath();
	context.arc(75, 75, 40, 0, Math.PI*2, true);
	context.closePath();
	context.fillStyle = "#FFA500";
	context.fill(); // Если нужен круг, можно залить окружность

  }
}
</script>

<h3>Кривые Безье</h3>
<p>Для создания кривых  Безье в HTML5 Canvas используется метод bezierCurveTo(). Кривые Безье задаются  с помощью начальной точки, двух контрольных точек и конечной точки. В отличие  от квадратичных кривых, кривые Безье в HTML 5 Canvas определяются двумя  контрольными точками вместо одной, позволяя создавать кривые с более сложным  очертанием.</p>
<p> Метод bezierCurveTo()  выглядит следующим образом:</p>
<xmp id="scriptHTML">
context.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
</xmp>
<p>Пример рисования  кривой Безье в HTML 5 Canvas:</p>

<xmp id="scriptHTML">
<canvas id="myCanvas3" width="500" height="250">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>

<script>
    var canvas = document.getElementById("myCanvas3");
    var context = canvas.getContext("2d");
 
    context.moveTo(200, 50);
 
    var controlX1 = 100;
    var controlY1 = 100;
    var controlX2 = 480;
    var controlY2 = 150;
    var endX = 300;
    var endY = 170;
 
    context.bezierCurveTo(controlX1, controlY1, controlX2, 
        controlY2, endX, endY);
 
    context.lineWidth = 10;
    context.strokeStyle = "black"; // line color
    context.stroke();

</script>
</xmp>

<canvas id="myCanvas3" width="500" height="250">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>

<script>
    var canvas = document.getElementById("myCanvas3");
    var context = canvas.getContext("2d");
 
    context.moveTo(0, 130);
 
    var controlX1 = 0;
    var controlY1 = 100;
    var controlX2 = 480;
    var controlY2 = 50;
    var endX = 88;
    var endY = 70;
 
    context.bezierCurveTo(controlX1, controlY1, controlX2, 
        controlY2, endX, endY);
 
    context.lineWidth = 10;
    context.strokeStyle = "black"; // line color
    context.stroke();


</script>

<h3>Контуры</h3>
<p>Контуры Canvas позволяют рисовать фигуры любой формы. Сначала  нужно нарисовать &quot;каркас&quot;, а потом можно использовать стили линий или  заливки, если это необходимо. Чтобы начать рисование контура, используется  метод beginPath(), потом рисуется  контур, который можно составить из линий, кривых и других примитивов. Как  только рисование фигуры окончено, можно вызвать методы назначения стиля линий и  заливки, и только потом вызвать функцию closePath() для завершения рисования фигуры.</p>
<xmp id="scriptHTML">
<canvas id="myCanvas4" width="500" height="250">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>

<script>
    var canvas = document.getElementById("myCanvas4");
    var context = canvas.getContext("2d");
 
    // Задаем свойства заливки и линий.
	context.fillStyle = '#00f';
	context.strokeStyle = '#f00';
	context.lineWidth = 4;

	context.beginPath();	
	// Начинаем рисовать треугольник с верхней левой точки.
	context.moveTo(10, 10); // перемещаемся к координатам (x,y)
	context.lineTo(100, 10);
	context.lineTo(100, 10);
	context.lineTo(350, 150);
	context.bezierCurveTo(50, 150, 40, 80, 100, 10);
	// Заполняем фигуру заливкой и применяем линии
	// Фигура не будет отображена, пока не будет вызван хотя бы один из этих методов.
	context.fill();
	context.stroke();
	context.closePath();

</script>
</xmp>
<canvas id="myCanvas4" width="500" height="250">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>

<script>
var canvas = document.getElementById("myCanvas4")
var contex = canvas.getContext("2d");
contex.fillStyle = '#321';
contex.lineWidth = 3;

contex.beginPath();
contex.moveTo(30,30);
contex.lineTo(150,30);
contex.lineTo(150,150);
contex.lineTo(100,100);
contex.bezierCurveTo(20,150,20,40,30,30);
contex.fill();
contex.closePath();

</script>

<h3>Вставка  изображений в Canvas</h3>
<p>Метод drawImage позволяет вставлять другие изображения (img и canvas) на канву. В некоторых браузерах существует возможность рисования SVG-изображений внутри элемента canvas. drawImage метод,  который может принимать три, пять или девять аргументов:</p>
<ul>
  <li>Три  аргумента: Базовое использование метода drawImage включает один аргумент для указания  изображения, которое необходимо вывести на канве, и два аргумента для задания  координат.</li>
  <li>Пять  аргументов: Используются предыдущие три аргумента и еще два, задающие ширину и  высоту вставляемого изображения (в случае если вы хотите изменить размеры  изображения при вставке).</li>
  <li>Девять  аргументов: Используются предыдущие пять аргументов и еще четыре: два для  координат области внутри исходного изображения и два для ширины и высоты  области внутри исходного изображения для обрезки изображения перед вставкой в Canvas.</li>
</ul>
<p>Пример вставки  изображения:</p>
<xmp id="scriptHTML">

<canvas id="myCanvas5" width="600" height="600">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>


<script>
    var canvas = document.getElementById("myCanvas5");
    var context = canvas.getContext("2d");

// Создаем объект изображения
var img = new Image();

// Привязываем функцию к событию onload
// Это указывает браузеру, что делать, когда изображение загружено
img.onload = function() {
// Три аргумента: элемент img или canvas, координаты для вывода на канву (x,y).
context.drawImage(img, 10, 10);

// Пять аргументов: элемент img или canvas, координаты для вывода на канву (x,y),
// ширина и высота для изменения размеров перед выводом
context.drawImage(img, 10, 315, 500, 100);

// Девять аргументов: элемент img или canvas, координаты, ширина и высота для обрезки изображения,
// координаты для вывода на канву (x,y), ширина и высота для изменения размеров перед выводом.
context.drawImage(img, 120, 120, 100, 100, 10, 420, 150, 100);

};

// Загружаем файл изображения
img.src = "image/5.png";

</script>
</xmp>

<canvas id="myCanvas5" width="600" height="600">
  <p>&nbsp;</p>
  <p>Альтернативное содержимое, которое будет показано, если браузер не поддерживает Canvas. 
    В данном случае можно написать сообщение «Ваш браузер не поддерживает CANVAS» </p>
</canvas>


<script>
var canvas = document.getElementById("myCanvas5");
var context = canvas.getContext('2d');

var img = new Image();

img.onload = function()
{
	context.drawImage(img, 10, 10);
	
	context.drawImage(img, 10, 315, 500, 120);
	
	context.drawImage(img, 150, 150, 100, 100, 10, 450, 100, 100);
}

img.src = "image/5.png";

</script>


<h3>&nbsp;</h3>
<p>&nbsp;</p>
</div>
<footer>
<p> HTML5&amp;CSS. Профессиональная веб-разработка. Уровень 2.  </p>
<p> Все права защищены. Использование материалов сайта только со ссылкой на первоисточник </p>
</footer>
</body>
</html>
